using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;

namespace MacroBuilder
{
    // Sources:
    // http://pinvoke.net/default.aspx/user32/RegisterHotKey.html
    // https://docs.microsoft.com/en-gb/windows/win32/api/winuser/nf-winuser-registerhotkey
    // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globaladdatoma

    [Flags]
    public enum KeyModifiers
    {
        None = 0,
        /// <summary>
        /// Either ALT key must be held down for the hotkey to be triggered.
        /// </summary>
        Alt = 0x0001,
        /// <summary>
        /// Either CTRL key must be held down for the hotkey to be triggered.
        /// </summary>
        Control = 0x0002,
        /// <summary>
        /// Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.
        /// </summary>
        NoRepeat = 0x4000,
        /// <summary>
        /// Either SHIFT key must be held down for the hotkey to be triggered.
        /// </summary>
        Shift = 0x0004,
        // Either WINDOWS key was held down. These keys are labeled with the Windows logo.
        // Keyboard shortcuts that involve the WINDOWS key are reserved for use by the
        // operating system.
        Windows = 0x0008
    }

    public class RegisterHotKeyWrapper : IMessageFilter, IDisposable
    {
        /// <summary>
        /// Holds information about a key that has been registered as a Hot Key.
        /// </summary>
        private class RegisteredKey
        {
            public int Id;
            public KeyModifiers Modifiers;
            public Keys Key;

            public RegisteredKey(int id, KeyModifiers modifiers, Keys key)
            {
                Id = id;
                Key = key;
                Modifiers = modifiers;
            }
        }

        #region P/Invoke stuff.

        // For getting a random ID from the 'atom table' that does not conflict.
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern ushort GlobalAddAtom(string atomIdentifier);

        // For removing an ID from the 'atom table'.
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern ushort GlobalDeleteAtom(ushort nAtom);

        /// <summary>
        /// Define a system-wide hot key.
        /// </summary>
        /// <param name="hWnd">
        /// A handle to the window that will receive WM_HOTKEY messages generated by the
        /// hot key. If this parameter is NULL, WM_HOTKEY messages are posted to the
        /// message queue of the calling thread and must be processed in the message loop.
        /// </param>
        /// <param name="id">
        /// The identifier of the hot key. If the hWnd parameter is NULL, then the hot
        /// key is associated with the current thread rather than with a particular
        /// window.
        /// </param>
        /// <param name="fsModifiers">
        /// The keys that must be pressed in combination with the primary <paramref name="key"/> 
        /// in order to generate the WM_HOTKEY message.
        /// </param>
        /// <param name="vk">The virtual-key code of the hot key.</param>
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool RegisterHotKey(IntPtr hWnd, int id,
            KeyModifiers fsModifiers, Keys key);

        /// <summary>
        /// Frees a hot key previously registered by the calling thread.
        /// </summary>
        /// <param name="hWnd">
        /// A handle to the window associated with the hot key to be freed. This parameter
        /// should be NULL if the hot key is not associated with a window.
        /// </param>
        /// <param name="id">
        /// The identifier of the hot key to be freed.
        /// </param>
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool UnregisterHotKey(IntPtr hWnd, int id);

        #endregion

        #region Constants

#pragma warning disable IDE1006 // Naming Styles
        private const int WM_HOTKEY = 0x0312;
#pragma warning restore IDE1006 // Naming Styles

        #endregion

        /// <summary>
        /// Creates a unique identifier for the given key on this current thread.
        /// </summary>
        private string CreateAtomIdentifier(Keys key, KeyModifiers modifiers) => Thread.CurrentThread.ManagedThreadId.ToString("X8") + GetType().FullName + key.ToString() + modifiers.ToString();

        /// <summary>
        /// A dictionary of all the keys that have been registered as 'Hot Keys'
        /// </summary>
        private readonly List<RegisteredKey> _registeredKeys = new();

        /// <summary>
        /// The window handle that WM_HOTKEY messages are sent to.
        /// </summary>
        private readonly nint _windowHandle;

        private readonly object _registerLocker = new();

        private bool _disposedValue;

        public delegate void HotKeyPressedHandler(Keys key);
        /// <summary>
        /// Triggered when a registered hot key is pressed.
        /// </summary>
        public event HotKeyPressedHandler? HotKeyPressed;

        public RegisterHotKeyWrapper(nint windowHandle)
        {
            _windowHandle = windowHandle;

            // Request that WndProc messages filter through us before going to their intended destination.
            Application.AddMessageFilter(this);
        }

        /// <summary>
        /// Determines whether a key/modifier combination has already been registered.
        /// </summary>
        /// <returns><see langword="true"/> if the key/modifier combination is already registered, or <see langword="false"/> if not.</returns>
        private bool IsKeyRegistered(Keys key, KeyModifiers modifiers)
        {
            for (int i = 0; i < _registeredKeys.Count; i++)
            {
                if (_registeredKeys[i].Key == key && _registeredKeys[i].Modifiers == modifiers)
                {
                    return true;
                }
            }

            return false;
        }

        public bool RegisterKey(Keys key, KeyModifiers modifiers = KeyModifiers.None)
        {
            lock (_registerLocker)
            {
                if (_disposedValue)
                {
                    throw new ObjectDisposedException(nameof(RegisterHotKeyWrapper));
                }

                if (IsKeyRegistered(key, modifiers))
                {
                    return false;
                }

                // The unique identifier given by the global atom table.
                ushort hotkeyID = GlobalAddAtom(CreateAtomIdentifier(key, modifiers));

                bool registeredSuccessfully = RegisterHotKey(_windowHandle, hotkeyID, modifiers, key);

                if (!registeredSuccessfully)
                {
                    UnregisterHotKey(_windowHandle, hotkeyID);
                    return false;
                }

                _registeredKeys.Add(new RegisteredKey(hotkeyID, modifiers, key));

                return true;
            }
        }

        public bool PreFilterMessage(ref Message m)
        {
            // The message is regarding a hot key and relates to our window handle
            if (m.Msg == WM_HOTKEY
               && m.HWnd == _windowHandle)
            {
                for (int i = 0; i < _registeredKeys.Count; i++)
                {
                    // The id of the hotkey is one that we manage.
                    if (m.WParam == (nint)_registeredKeys[i].Id)
                    {
                        // Inform subscribers that key has been pressed.
                        HotKeyPressed?.Invoke(_registeredKeys[i].Key);
                        return true;
                    }
                }
            }

            // Leave the message alone and pass it on to the next filter/control.
            return false;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    // Dispose managed objects.

                    lock (_registerLocker)
                    {
                        // Ensure that we are no longer linked as a message filter
                        // as otherwise we will not be garbage collected.
                        Application.RemoveMessageFilter(this);

                        // Unregister all keys we have registered.
                        for (int i = 0; i < _registeredKeys.Count; i++)
                        {
                            UnregisterHotKey(_windowHandle, _registeredKeys[i].Id);
                        }
                    }
                }

                // Free unmanaged resources (unmanaged objects) and override finalizer
                // Set large fields to null
                _disposedValue = true;
            }
        }

        /// <summary>
        /// Unregisters all hot keys and unhooks from the window that was receiving messages.
        /// </summary>
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}